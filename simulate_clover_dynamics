# === Complete and induced dynamics for clover-type networks ===
# Includes: network construction, complete simulation, induced logic, and indicator calculation.

import networkx as nx
import numpy as np
import itertools
import pandas as pd
import matplotlib.pyplot as plt

# === 0. Delete repeated values ===
def get_distinct_sets(list_of_sets):
    seen = set()
    result = []

    for s in list_of_sets:
        fs = frozenset(s)
        if fs not in seen:
            seen.add(fs)
            result.append(s)

    return result

# === 1. Build Clover-type Network ===
def build_fully_specified_clover_network(N, p):
    A = np.zeros((N + 1, N + 1), dtype=int)
    O = [1]
    A[0, 1] = 1
    for n in range(3, N + 2):
        if np.random.rand() < p:
            A[0, n - 1] = 1
            O.append(n - 1)
    O = sorted(O)
    s = len(O) - 1
    O.append(N)
    for k in range(1, s + 2):
        nk_prev, nk = O[k - 1], O[k]
        if nk_prev != nk - 1:
            for n in range(nk_prev, nk - 1):
                A[n, n + 1] = 1
    for k in range(2, s + 2):
        nkm1 = O[k - 1] - 1
        if nkm1 > 0:
            A[nkm1, 0] = 1
    A[N, 0] = 1
    if N not in O[:-1]:
        A[N - 1, N] = 1
    A[0, 0] = 0
    return A

# === 1.2 Build the NetworkX graph ===
def build_clover_graph(N, p, seed=None):
    """
    Construye un DiGraph de NetworkX a partir de la matriz clover original.
    """
    A = build_fully_specified_clover_network(N, p, seed)
    G = nx.DiGraph()
    G.add_nodes_from(range(N + 1))
    for i in range(N + 1):
        for j in range(N + 1):
            if A[i, j] == 1:
                G.add_edge(i, j, sign=1)  # signo +1 por defecto
    return G

# === 2. Assign Signs to Interactions ===
def assign_interaction_signs(A, q):
    if seed is not None:
        np.random.seed(seed)
    for u, v in G.edges():
        G[u][v]['sign'] = -1 if np.random.rand() < q else 1
    return G

# === 3. Boolean Dynamics ===
def simulate_full_boolean_dynamics(G, T):
    """
    Simulate the complete dynamics with the multiplicative rule:
      x_i(t+1) = ∏_{p→i} [sign(p→i) * x_p(t)]
    """
   # def product_update(state):
   #     new = {}
   #     for node in G.nodes():
   #         prod = 1
   #         for pred in G.predecessors(node):
   #             prod *= G[pred][node]['sign'] * state[pred]
   #         new[node] = prod  # ya es +1 o -1
   #     return new

    """
    Simulates the complete dynamics (sign) in all initial states.
    """
    def sign_update(state):
        # state: dict nodo->±1
        new = {}
        for node in G.nodes():
            total = sum(G[p][node]['sign'] * state[p] for p in G.predecessors(node))
            new[node] = 1 if total >= 0 else -1
        return new

    results = {}
    N = G.number_of_nodes()
    # List all initial configurations ±1
    for init in itertools.product([-1, 1], repeat=N):
        state = {i: init[i] for i in range(N)}
        seen = {tuple(init): 0}
        orbit = [tuple(init)]
        for t in range(1, T + 1):
            state = sign_update(state)
           # state = product_update(state)
            tup = tuple(state[i] for i in range(N))
            if tup in seen:
                start = seen[tup]
                attractor = orbit[start:]
                results[init] = {
                    'orbit': orbit,
                    'transient': start,
                    'period': len(attractor),
                    'attractor': attractor
                }
                break
            seen[tup] = t
            orbit.append(tup)
    return results

# === 4. Dominant Set and Depth ===
def get_dominant_set_and_depth(A):
    N = A.shape[0]
    U = [0]
    depth = 0
    determined = set(U)
    while len(determined) < N:
        new_determined = set()
        for v in range(N):
            if v not in determined:
                inputs = np.where(A[:, v] != 0)[0]
                if all(i in determined for i in inputs):
                    new_determined.add(v)
        if not new_determined:
            break
        determined.update(new_determined)
        depth += 1
    return sorted(U), depth

# === 5. Calculation of dynamic indicators ===
def analyze_dynamics(results):
    """
    Calculate:
        - Nc: number of unique attractors
        - mp: mean period
        - mtm: mean transient
        - mtM: maximum transient
    """
    # Unique attractors
    unique = [set(v['attractor']) for v in results.values()]
    Nc = len(get_distinct_sets(unique))
    periods = [v['period'] for v in results.values()]
    transients = [v['transient'] for v in results.values()]
    mp = np.mean(periods)
    mtm = np.mean(transients)
    mtM = np.max(transients)
    return Nc, mp, mtm, mtM

# === 6. Clover cycle and S vector detection ===
def get_clover_cycles_and_S(A, S_mat):
    """
    Given A and S_mat, detect cycles that start from 0 and return to 0 by linear paths, 
    calculate the sign of each cycle and construct the vector S.
    """
    N = A.shape[0]
    cycles, signs = [], []
    for j in range(1, N):
        if A[0, j] == 1:
            path, sign = [0], S_mat[0, j]
            curr = j
            while True:
                path.append(curr)
                if A[curr, 0] == 1:
                    path.append(0)
                    sign *= S_mat[curr, 0]
                    cycles.append(path)
                    signs.append(sign)
                    break
                # next node on linear path
                nxt = np.where(A[curr] == 1)[0]
                if len(nxt) != 1:
                    break
                sign *= S_mat[curr, nxt[0]]
                curr = nxt[0]
    max_len = max(len(c) for c in cycles)
    S_vec = np.zeros(max_len - 1, dtype=int)
    for c, s in zip(cycles, signs):
        S_vec[len(c) - 2] += s
    return cycles, S_vec

# === 7. Induced phi function ===
def get_phi_function(S_vec):
    """
    Returns the function phi(y) according to:
     phi(y) = sign(sum(S_i * y_i) | y_0)
    """
    def phi(y):
        total = sum(S_vec[i] * y[i] for i in range(len(S_vec)))
        return int(np.sign(total)) if total != 0 else y[0]
    return phi

# === 8. Induced dynamics simulation ===
def simulate_induced_dynamics(phi, segments):
    results = {}
    ell = len(segments[0])
    for init in segments:
        hist = list(init)
        seen = {' '.join(map(str, hist)): 0}
        orbit = [tuple(hist)]
        for t in range(1, 2**ell + 1):
            nv = phi(hist)
            hist = [nv] + hist[:-1]
            key = ' '.join(map(str, hist))
            if key in seen:
                start = seen[key]
                attractor = orbit[start:]
                results[init] = {
                    'orbit': orbit,
                    'transient': start,
                    'period': len(attractor),
                    'attractor': attractor
                }
                break
            seen[key] = t
            orbit.append(tuple(hist))
    return results

# === 10. Full pipeline: compare full vs. induced ===
def full_vs_induced_clover(N=5, p=0.5, q=0.5, seed=None):
    """
    Builds the Clover network, assigns signs, simulates full and induced dynamics,
    and returns a DataFrame with Nc, mp, mtm, and mtM for each case.
    """
    # 1) Clover graph and signs
    G = build_clover_graph(N, p, seed)
    G = assign_edge_signs(G, q, seed)
    # === Circular positions with node 0 in the center ===
    pos = {0: (0, 0)}
    angles = np.linspace(0, 2 * np.pi, N, endpoint=False)
    for idx, angle in enumerate(angles, start=1):
        pos[idx] = (np.cos(angle), np.sin(angle))

    # === Drawing the graph ===
    plt.figure(figsize=(6, 6))
    nx.draw(
        G, pos,
        with_labels=True,
        node_color='lightblue',
        node_size=800,
        arrowsize=20,
        font_weight='bold'
    )
    edge_labels = nx.get_edge_attributes(G, 'sign')
    nx.draw_networkx_edge_labels(
        G, pos,
        edge_labels=edge_labels,
        label_pos=0.5,
        font_color='red'
    )


    # 2) A y S_mat matrices
    A = nx.to_numpy_array(G, dtype=int)
    S_mat = np.zeros_like(A, dtype=int)
    for u, v, data in G.edges(data=True):
        S_mat[u, v] = data['sign']
    print('A=', '\n',A)
    print('S_mat=', '\n', S_mat)


    # 3) Full dynamics
    T = 2**N + 1
    full_res = simulate_full_boolean_dynamics(G, T)
    Nc_f, mp_f, mtm_f, mtM_f = analyze_dynamics(full_res)
    print('full_res=', full_res)
    #print('Nc=', Nc_f, 'mp=', mp_f, 'mtm=', mtm_f, 'mtM=', mtM_f)


    # 4) Cycle detection and phi function
    c, S_vec = get_clover_cycles_and_S(A, S_mat)
    phi = get_phi_function(S_vec)
    print('ciclos=', c)
    print('S_vec=', S_vec)
    #print('phi=', phi)

    # 5) Stories to evaluate
    #segments = compute_h_segments(full_res, len(S_vec), dom=0)
    ell=len(S_vec)
    segments=list(itertools.product([-1,1], repeat=ell))  # full 2^ell space
    #print('Segments=', segments)

    # 6) Induced dynamics
    ind_res = simulate_induced_dynamics(phi, segments)
    Nc_i, mp_i, mtm_i, mtM_i = analyze_dynamics(ind_res)
    print('ind_res=', ind_res)

    # 7) Output
    df = pd.DataFrame([
        {'Tipo': 'Completa', 'Nc': Nc_f, 'mp': mp_f, 'mtm': mtm_f, 'mtM': mtM_f},
        {'Tipo': 'Inducida', 'Nc': Nc_i, 'mp': mp_i, 'mtm': mtm_i, 'mtM': mtM_i}
    ])
    return df

# === Example of execution ===
df_comparison = full_vs_induced_clover(N=3, p=0.5, q=0.5)
df_comparison
